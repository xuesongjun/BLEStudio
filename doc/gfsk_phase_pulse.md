# GFSK 调制中的相位脉冲与脉冲长度

## 概述

在 GFSK (Gaussian Frequency Shift Keying) 调制中，有几个核心概念：

| 概念 | 符号 | 含义 | BLE 典型值 |
|------|------|------|------------|
| **符号周期** | T | 一个比特持续的时间 | 1 μs (LE 1M) |
| **频率脉冲** | g(t) | 单个比特对瞬时频率的贡献形状 | 高斯钟形曲线 |
| **相位脉冲** | q(t) | 频率脉冲的积分，描述相位累积 | S 形曲线 |
| **脉冲长度** | L | 频率脉冲跨越的符号周期数 | 1 (Full Response) |

## 符号周期 T (Symbol Period)

### 定义

**符号周期是一个比特（符号）持续的时间长度**。

```
符号周期 T = 1 / 符号率

BLE LE 1M: 符号率 = 1 MHz → T = 1 μs (每个比特持续 1 微秒)
BLE LE 2M: 符号率 = 2 MHz → T = 0.5 μs (每个比特持续 0.5 微秒)
```

### 与采样的关系

```
每符号采样数 (sps) = 采样率 / 符号率

BLE 典型配置:
  采样率 = 8 MHz, 符号率 = 1 MHz → sps = 8
  采样率 = 8 MHz, 符号率 = 2 MHz → sps = 4
```

### 时间轴示意

```
          |<--- T --->|<--- T --->|<--- T --->|
时间:     0          1μs         2μs         3μs
采样点:   0  1  2  3  4  5  6  7  8  9 10 11 12 ...
比特:     |   bit 0   |   bit 1   |   bit 2   |
          |← 8 samples→|← 8 samples→|← 8 samples→|
```

## 从 FSK 到 GFSK

### 传统 FSK - 方波频率

在传统 FSK 中，频率**瞬间跳变**：

```
理想 FSK 频率波形:
频率 ^
 +Δf |████████        ████████
   0 |--------████████--------████████
 -Δf |
     +---------------------------------> t
          bit=1   bit=0   bit=1   bit=0
```

**问题**: 方波的边缘包含无穷多高频分量，导致频谱很宽（带外辐射大）。

### GFSK - 平滑频率变化

GFSK 使用**高斯滤波器**平滑频率：

```
GFSK 频率波形:
频率 ^
 +Δf |   ___          ___
     |  /   \        /   \
   0 |_/     \______/     \___
     |        \    /
 -Δf |         \__/
     +---------------------------------> t
          bit=1   bit=0   bit=1   bit=0
```

**优点**:
1. 频谱更窄，带外辐射小
2. 满足 BLE 频谱模板要求

**代价**:
1. 频率变化有延迟（不是瞬间到达目标值）
2. 可能产生符号间干扰 (ISI)

## 频率脉冲 g(t)

### 什么是频率脉冲？

**频率脉冲描述单个比特对瞬时频率的贡献形状**。

想象你发送一个 bit=1：
- 在理想 FSK 中：频率立即跳到 +Δf，持续整个符号周期，然后跳回
- 在 GFSK 中：频率**逐渐**上升到峰值，然后**逐渐**下降

这个"逐渐上升再下降"的形状就是**频率脉冲 g(t)**。

### 形状

```
单个 bit=1 的频率贡献 g(t):

频率 ^
     |      ____     ← 峰值 (在符号中心)
     |     /    \
     |    /      \
     |   /        \
   0 |__/          \__
     +-----------------> t
    -T/2    0    T/2
     ↑      ↑      ↑
  符号开始  中心  符号结束
```

### 关键特性

1. **钟形曲线** (高斯形状)
2. **对称**: 在 t=0 (符号中心) 达到峰值
3. **面积 = 0.5**: 积分后相位变化为 0.5 (归一化)

### 数学表达

```
g(t) = (1/2T) × [Q(K×(t-T/2)) - Q(K×(t+T/2))]
```

其中：
- T: 符号周期
- K = 2πBT / √ln(2)
- BT: 带宽时间积 (BLE 使用 BT = 0.5)
- Q(x): Q 函数 = 0.5 × erfc(x/√2)

### BT 参数的影响

BT (Bandwidth-Time product) 控制高斯滤波器的"宽度"：

```
BT 小 (如 0.3):          BT 大 (如 0.7):
      ___                     _____
     /   \                   /     \
    /     \                 /       \
___/       \___          __/         \__

脉冲窄，变化快            脉冲宽，变化慢
频谱宽，ISI 小            频谱窄，ISI 可能大
```

**BLE 使用 BT = 0.5**，是频谱效率和 ISI 的平衡点。

## 相位脉冲 q(t)

### 定义

相位脉冲是频率脉冲的积分：

```
q(t) = ∫[−∞ to t] g(τ) dτ
```

### 物理意义

- **q(t) 描述单个符号引起的相位累积**
- q(−∞) = 0 (符号开始前无贡献)
- q(+∞) = 0.5 (符号结束后总相位贡献为 0.5)

### 形状

```
q(t) 相位脉冲 (BT=0.5, L=1)
     ^
 0.5 |........................____
     |                   ___/
     |               ___/
     |           ___/
     |       ___/
   0 |______/
     +-------------------------> t
    -T/2    0    T/2    T
```

相位脉冲是一个 S 形曲线（sigmoid），从 0 平滑过渡到 0.5。

### BLE Studio 中的实现

```python
# phase_pulse 有 N+1 个点 (N = samples_per_symbol)
# phase_pulse[0] = 0
# phase_pulse[N] = 0.5

phase_pulse = [0, 0.047, 0.107, 0.176, 0.250, 0.324, 0.393, 0.453, 0.500]
#              ^                                                    ^
#              |                                                    |
#           符号开始                                              符号结束
```

## 脉冲长度 L (Pulse Length)

### 定义

脉冲长度 L 表示频率脉冲跨越多少个符号周期。

### Full Response vs Partial Response

| 类型 | L 值 | 特点 |
|------|------|------|
| **Full Response** | L = 1 | 脉冲完全包含在一个符号周期内，无 ISI |
| **Partial Response** | L > 1 | 脉冲扩展到多个符号周期，有 ISI |

### BLE 规范

**BLE 使用 Full Response (L = 1)**：
- 每个符号的频率脉冲完全包含在一个符号周期内
- 符号边界处频率可能不连续（但相位连续）
- 简化了解调器设计

### L = 1 vs L = 2 对比

```
L = 1 (Full Response) - 每个符号的脉冲独立:

频率 ^     sym0       sym1       sym2
     |    ┌──┐      ┌──┐      ┌──┐
     |   /    \    /    \    /    \
     |  /      \  /      \  /      \
   0 |─/        \/        \/        \─
     +────────────────────────────────> t
     |<-- T -->|<-- T -->|<-- T -->|

     每个脉冲只在自己的符号周期内有效
     接收端判决时，只看当前符号，不受邻居影响


L = 2 (Partial Response) - 脉冲跨越符号边界:

频率 ^
     |      sym0 的脉冲
     |    ┌────────┐
     |   /          \
     |  /    sym1    \    ← sym0 的尾巴延伸到 sym1 的区域！
   0 |─/              \─────
     +────────────────────────────────> t
     |<-- T -->|<-- T -->|

     sym0 的脉冲"拖尾"到 sym1 的区域
     接收端在判决 sym1 时，会受到 sym0 的残留影响
     这就是符号间干扰 (ISI)!
```

## 符号间干扰 (ISI) 详解

### 什么是 ISI？

**符号间干扰 (Inter-Symbol Interference)** 是指一个符号的信号"泄漏"到相邻符号的区域，影响接收端的判决。

### 为什么 GFSK 可能产生 ISI？

高斯脉冲理论上延伸到无穷远（虽然能量衰减很快）：

```
理想高斯脉冲:
     ^
     |        │
     |       /│\
     |      / │ \
     |     /  │  \
     |    /   │   \
     |___/    │    \___  ← 尾巴延伸到邻居
     +────────────────────> t
          sym0│sym1
              │
              └── 符号边界
```

### BLE 如何避免 ISI？

**使用 Full Response (L=1)**：强制将脉冲"截断"在一个符号周期内：

```
Full Response 截断:

     ^
     |     ┌─────┐    ← 人为截断边界
     |    /│     │\
     |   / │     │ \
     |  /  │     │  \
     |_/   │     │   \_
     +─────┴─────┴──────> t
           sym0

     脉冲被限制在一个符号周期内
     代价：符号边界处频率可能不连续
     好处：完全没有 ISI
```

### ISI vs 无 ISI 的接收效果

```
无 ISI (L=1):                        有 ISI (L=2):

在判决点采样:                        在判决点采样:
    ↓                                    ↓
    │    只有当前符号                     │    当前符号 + 前一符号残留
    │    的贡献                           │
    ▼                                    ▼
  ┌───┐                               ┌───┐
  │ 1 │ ← 清晰判决                    │0.7│ ← 被干扰，可能判错
  └───┘                               └───┘
```

### 为什么有些系统故意使用 Partial Response？

虽然有 ISI，但 Partial Response 也有优点：

1. **更窄的频谱**：脉冲更平滑，高频分量更少
2. **更高的频谱效率**：相同带宽可传更多数据
3. **可以用 Viterbi 等算法解码**：利用 ISI 的可预测性

**但 BLE 选择简单性**：使用 Full Response，不需要复杂的均衡算法。

## 调制公式

### 完整公式

对于 N 个符号的调制：

```
phase(t) = 2πh × Σ[k=0 to N-1] symbol[k] × q(t - k×T)
```

其中：
- h: 调制指数 (BLE 使用 h = 0.5)
- symbol[k]: 第 k 个符号值 (+1 或 -1)
- q(t): 相位脉冲
- T: 符号周期

### BLE Studio 实现

```python
# 对于 Full Response (L=1)，简化为逐符号累加
for i in range(num_symbols):
    sym = symbols[i]  # +1 或 -1

    # 当前符号的相位 = 累积相位 + 本符号贡献
    # phase_pulse[:N] 是 N 个采样点的相位形状
    phase[start:start+N] = cumulative_phase + h * sym * phase_pulse[:N] * 2π

    # 更新累积相位
    # phase_pulse[N] = 0.5，所以每符号贡献 h × 0.5 × 2π = h × π
    cumulative_phase += h * sym * phase_pulse[N] * 2π
```

## 关键参数总结

### BLE 参数

| 参数 | 值 | 说明 |
|------|-----|------|
| BT | 0.5 | 带宽时间积 |
| h | 0.5 | 调制指数 |
| L | 1 | 脉冲长度 (Full Response) |
| 符号率 | 1 MHz (LE 1M) / 2 MHz (LE 2M) | - |

### 相位变化

每个符号的相位变化：

```
Δphase = h × symbol × q(T) × 2π
       = 0.5 × (±1) × 0.5 × 2π
       = ±π/2
       ≈ ±1.5708 rad
```

但由于 phase_pulse 在 T 时刻的实际值是 0.4531（而不是 0.5），MATLAB 的实际相位变化是：

```
Δphase = 0.5 × (±1) × 0.4531 × 2π
       ≈ ±1.4234 rad
```

### 频率偏移

瞬时频率偏移：

```
f(t) = (1/2π) × d(phase)/dt
     = h × symbol × g(t) × symbol_rate

峰值频偏 ≈ h × symbol_rate × 1.3  (对于 BT=0.5)
        = 0.5 × 1MHz × 1.3
        ≈ 325 kHz (峰值)

平均频偏 = h × symbol_rate / 2
        = 0.5 × 1MHz / 2
        = 250 kHz
```

## 为什么 phase_pulse[-1] = 0.4531 而不是 0.5？

### 离散化效应

在连续时间域，q(∞) = 0.5。但在离散实现中：

1. **采样点有限**：我们只取 N 个点 (如 8 sps)
2. **截断效应**：高斯脉冲在边界处不完全为零
3. **积分近似**：离散积分只是近似值

### MATLAB 的处理

MATLAB 的 `bleWaveformGenerator` 使用以下方法：

1. 在高过采样率 (64×) 下计算精确脉冲
2. 归一化频率脉冲使其积分为 0.5
3. 下采样到目标采样率
4. 相位脉冲 = [0, cumsum(freq_pulse)]

结果是 phase_pulse 有 N+1 个点：
- phase_pulse[0] = 0
- phase_pulse[N] = 0.5 (精确)

但前 N 个点的值取决于高斯脉冲的具体形状：
```
phase_pulse = [0, 0.047, 0.107, 0.176, 0.250, 0.324, 0.393, 0.453, 0.500]
                                                              ↑
                                                        这是 phase_pulse[7]
                                                        不是 0.5！
```

## 总结

| 术语 | 是什么 | 不是什么 |
|------|--------|----------|
| **Pulse Length (L)** | 频率脉冲跨越的符号数 | 相位脉冲的最终值 |
| **Phase Pulse q(t)** | 频率脉冲的积分，描述相位形状 | 频率脉冲本身 |
| **phase_pulse[-1]** | N 个采样点后的累积相位 (0.4531) | phase_pulse 的最大值 (0.5 在第 N+1 点) |

### 记忆要点

1. **L = 1** 表示 Full Response，BLE 使用此模式
2. **phase_pulse** 是 S 形曲线，从 0 到 0.5
3. **phase_pulse** 有 **N+1 个点**，不是 N 个点
4. 调制时使用 **前 N 个点** phase_pulse[:N]
5. 累积相位更新使用 **第 N+1 个点** phase_pulse[N] = 0.5

## 参考资料

1. **Bluetooth Core Specification v5.x**, Volume 6, Part A - Physical Layer
2. **J.B. Anderson** - *Digital Transmission Engineering*, Chapter 5: CPM
3. **MATLAB Documentation** - bleWaveformGenerator, gmskmod
4. **BLE Studio** - [modulator.py](../ble_studio/modulator.py)
