# 逻辑分析仪数据处理策略文档

本文档描述 `logic_analyzer_bin2wave.py` 工具的数据清洗和采样策略。

## 概述

该工具用于将 Kingst (金思特) 逻辑分析仪采集的并行数据转换为 IQ 波形数据。由于逻辑分析仪采样率与数据源时钟存在相位差异，且数据在时钟边沿附近可能出现亚稳态，需要通过数据清洗和智能采样策略来恢复正确的数据。

## 一、数据清洗策略 (Glitch Filter)

**代码位置**: `filter_glitches()` 函数

### 1.1 基础毛刺过滤

**目的**: 消除数据通道中由于亚稳态或噪声导致的短脉冲（毛刺）。

**策略**:
- 检测数据通道中宽度小于阈值的短脉冲
- 阈值计算公式: `min_pulse_width = 数据周期采样点数 × glitch_threshold`
- 默认 `glitch_threshold = 0.3`，即小于 30% 数据周期的脉冲被视为毛刺
- 将毛刺区域恢复为翻转前的原始值

**示例**:
```
采样率: 500 MHz, 数据速率: 32 MHz
数据周期: 500/32 ≈ 15.6 采样点
毛刺阈值: 15.6 × 0.3 ≈ 4 采样点
→ 宽度 < 4 采样点的脉冲被过滤
```

### 1.2 前半段保护机制

**目的**: 保护双稳态情况下的第一个有效脉冲，避免误删。

**背景**:
当数据在时钟边沿附近变化时，可能出现双稳态现象（如 0→1→0 或 1→0→1）。第一个短脉冲可能是真实数据，不应被过滤。

**策略**:
- 检测时钟信号的上升沿和下降沿位置
- 计算时钟半周期长度
- 如果短脉冲位于时钟周期的**前半段**，则**不进行过滤**
- 只过滤位于后半段的毛刺

**示意图**:
```
时钟周期:  |<-------- 前半段 -------->|<-------- 后半段 -------->|
           ↑ 时钟边沿

前半段的短脉冲: 保护，不过滤（可能是双稳态的第一个值）
后半段的短脉冲: 过滤（视为毛刺）
```

### 1.3 迭代清洗

**策略**:
- 多轮迭代执行毛刺过滤，直到没有新的毛刺被检测到
- 每轮处理不相邻的毛刺，避免重叠区域的处理冲突
- 最大迭代次数: 100 轮

## 二、采样策略 (Data Extraction)

**代码位置**: `extract_value()` 函数

### 2.1 眼图分析确定基准延迟

**目的**: 为每个数据位找到最佳的采样时刻（作为默认值）。

**策略**:
- 对每个数据位，在时钟边沿后的搜索范围内分析稳定性
- 稳定性定义: 采样点与其相邻点值相同的比例
- 选择所有数据位综合稳定性最高的时间窗口
- 为上升沿（I 路）和下降沿（Q 路）分别计算延迟

**输出示例**:
```
=== 上升沿 (I) ===
data0: delay +11, stability 97.0%  |-+###==+++=#==+|
data1: delay +10, stability 99.8%  |+####=+-+###=+-|
...
```
眼图中 `#` 表示高稳定性区域，`+` 表示中等稳定性，`-` 表示低稳定性。

### 2.2 基于上下文的智能采样

**核心原理**: 根据边沿前后数据的变化情况，判断真实数据位置。

**规则**:

| 条件 | 采样策略 | 原因 |
|------|----------|------|
| 边沿前后值不同 + 有跳变 | 采样边沿后开始位置的值 | 数据跟着指示信号变了，当前变化的电平是真实信号 |
| 边沿前后值相同 + 有跳变 + 边沿前占比少 | 采样边沿后开始位置的值 | 真实数据，后面的跳变是下一数据提前来 |
| 边沿前后值相同 + 有跳变 + 边沿前占比多 | 采样后半段（眼图延迟位置） | 边沿后开始的值是上一路残留 |
| 周期内无跳变 | 使用眼图默认延迟位置 | 数据稳定，使用最佳采样点 |

**详细说明**:

1. **边沿前后值不同 + 有跳变**:
   - 说明数据跟着指示信号变了
   - 当前变化的电平就是真实信号
   - 采样边沿后开始位置的值

2. **边沿前后值相同 + 有跳变**:
   - 需要进一步判断边沿前后该值的占比
   - **边沿前占比少**（例如 `00*110000`）：边沿后开始的值是真实数据，采样边沿开始位置
   - **边沿前占比多**（例如 `111111*110000`）：边沿后开始的值是上一路残留，采样后半段

3. **无跳变**:
   - 数据稳定，使用眼图分析的默认延迟位置

**比例判断算法**:
- 统计边沿前连续相同值的数量 (`count_before`)
- 统计边沿后连续相同值的数量 (`count_after`)
- 如果 `count_before > count_after`，说明该值主要在边沿前，边沿后的是残留，采样后半段
- 否则，边沿后开始的值是真实数据

**示意图**:
```
情况1: 边沿前后值不同，有跳变
边沿前: 0  边沿后: [1,1,1,1,0,0,0,0...]
                   ↑ 采样这里 = 1 (数据跟着指示信号变了)

情况2a: 边沿前后值相同，边沿后占比多
边沿前: ..0,0,1  边沿后: [1,1,1,1,0,0,0,0...]
                 ↑ 采样这里 = 1 (边沿后1多，是真实数据)

情况2b: 边沿前后值相同，边沿前占比多
边沿前: ..1,1,1,1,1,1  边沿后: [1,1,0,0,0,0,0,0...]
                            ↑ 采样这里 = 0 (边沿前1多，边沿后的1是残留)

情况3: 无跳变
边沿前: 1  边沿后: [1,1,1,1,1,1,1,1...]
                            ↑ 采样眼图延迟位置
```

### 2.3 采样位置记录

**目的**: 确保 VCD 调试文件与 HTML 波形图同步。

**策略**:
- `extract_data()` 返回 `sample_info`，包含每个采样的实际位置
- `bin_to_vcd.py` 使用相同的位置信息生成 VCD 文件
- 保证两种输出格式完全一致，便于调试对比

## 三、策略配合流程

```
┌─────────────┐
│  原始数据   │
└──────┬──────┘
       ↓
┌─────────────────────────────┐
│  毛刺过滤 (保护前半段脉冲)   │
└──────┬──────────────────────┘
       ↓
┌─────────────────────────────┐
│  眼图分析 (确定基准延迟)     │
└──────┬──────────────────────┘
       ↓
┌─────────────────────────────┐
│  逐周期智能采样              │
│  - 有跳变: 采样边沿后开始值  │
│  - 无跳变: 使用眼图延迟      │
└──────┬──────────────────────┘
       ↓
┌─────────────┐
│  IQ 数据    │
└─────────────┘
```

## 四、配置参数说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `glitch_filter` | true | 是否启用毛刺过滤 |
| `glitch_threshold` | 0.3 | 毛刺阈值（相对数据周期的比例） |
| `eye_align` | true | 是否进行眼图对齐 |
| `search_range` | 15 | 眼图搜索范围（采样点数） |
| `adaptive_filter` | false | 是否启用自适应过滤（基于眼图的二次过滤） |

## 五、调试方法

1. **生成 VCD 文件**:
   ```bash
   python utils/bin_to_vcd.py utils/logic_analyzer_config.yaml
   ```

2. **使用 GTKWave 查看**:
   - `raw` 分组: 原始数据
   - `cl` 分组: 清洗后数据
   - `smp` 分组: 采样脉冲位置
   - `iq` 分组: 提取的 IQ 数据

3. **对比 HTML 波形图**:
   - VCD 和 HTML 使用相同的采样位置
   - 可以通过时间戳精确对应
